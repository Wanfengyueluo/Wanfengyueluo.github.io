---
title: å¹¶æŸ¥é›†
date: 2020-04-02 14:51:46
summary: å¹¶æŸ¥é›†çŸ¥è¯†ç‚¹
categories: Algorithm
tags: å¹¶æŸ¥é›†
toc: true
---

# å¹¶æŸ¥é›†çŸ¥è¯†ç‚¹æ±‡æ€»

## åŸºäºidçš„å¹¶æŸ¥é›†

æ€è·¯ï¼šè®¾ç½®`id`æ•°ç»„ï¼Œæ•°ç»„çš„æ¯ä¸ªå…ƒç´ æ˜¯å…ƒç´ æ ‡è¯†ã€‚åˆå§‹åŒ–æ¯ä¸ªå…ƒç´ çš„å€¼éƒ½ä¸ä¸€æ ·ï¼Œå¦‚æœå€¼ä¸€æ ·è¡¨ç¤ºå±äºåŒä¸€ä¸ªé›†åˆå†…çš„å…ƒç´ ã€‚

<!-- more -->

å®ç°ï¼š

```java
public class UnionFind {
	private int[] id;//åˆ†é‡id
   
	private int count;//è¿é€šåˆ†é‡æ•°é‡

	public UnionFind(int n) {
		count = n;
		id = new int[n];
		for (int i = 0; i < n; i++) {
			id[i] = i;//åˆå§‹åŒ–id
		}
	}

	public int find(int p) {
		return id[p];
	}

	public void union(int p, int q) {
		int pid = find(p);
		int qid = find(q);
		//æ­¤æ—¶å·²ç»åœ¨åŒä¸€ä¸ªåˆ†é‡ä¸­
		if (pid == qid) {
			return;
		}
		for (int i = 0; i < id.length; i++) {
			if (find(i) == pid) {
				id[i] = qid;//å°†pçš„åˆ†é‡é‡æ–°å‘½åä¸ºq
			}
		}
		count--;
	}
}
```

> find()å¾ˆå¿«ï¼Œä½†æ˜¯union()å¾ˆæ…¢

## åŸºäºparentçš„å¹¶æŸ¥é›†

æ€è·¯ï¼šä¸å†ä½¿ç”¨`id`æ•°ç»„ï¼Œè€Œä½¿ç”¨`parent`æ•°ç»„ï¼Œå®šä¹‰ä¸ºï¼š`parent[i]`è¡¨ç¤ºç´¢å¼•ä¸ºiçš„èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•ï¼Œåˆå§‹æ—¶ï¼Œæ¯ä¸ªå…ƒç´ éƒ½æŒ‡å‘è‡ªå·±ã€‚

ä»£ç ï¼š

```java
public class UnionFind {
	private int[] parent;//å­˜æ”¾ç¬¬ièŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ç´¢å¼•
    
	private int count;//è¿é€šåˆ†é‡æ•°é‡

	public UnionFind(int n) {
		count = n;
		parent = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}

	public int find(int p) {
		while (parent[p] != p) {
			p = parent[p];
		}
		return p;
	}

	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);
		if (pRoot == qRoot) {
			return;
		}
		parent[pRoot] = qRoot;//æˆ–è€…parent[pRoot]=qRoot;
		count--;
	}
}

```



## quick-unionåŸºäºsizeçš„ä¼˜åŒ–

æ€è·¯ï¼šåŸºäº`parent`çš„å¹¶æŸ¥é›†åœ¨ç»™ä¸¤ä¸ªå…ƒç´ åˆå¹¶æ—¶æ²¡æœ‰è€ƒè™‘å“ªä¸€ä¸ªå…ƒç´ ä½œä¸ºæ ¹ï¼Œæ­¤æ—¶å¯¹äº`find`ä¼šæœ‰å½±å“ã€‚å› æ­¤æˆ‘ä»¬ç»´æŠ¤ä¸€ä¸ª`size`æ•°ç»„ï¼Œè¡¨ç¤ºä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å…ƒç´ ä¸ªæ•°ï¼Œåœ¨`union`æ—¶å°†é›†åˆå…ƒç´ å°‘çš„æŒ‡å‘é›†åˆå…ƒç´ å¤šçš„èŠ‚ç‚¹çš„æ ¹ï¼Œä¼šä½¿å½¢æˆçš„æ ‘å±‚æ•°è¾ƒä½ã€‚

ä»£ç ï¼š

```java
public class UnionFind {
	private int[] parent;

	private int count;
	
	private int[] size;//ä»¥å½“å‰ç´¢å¼•ä¸ºæ ¹çš„å…ƒç´ ä¸ªæ•°

	public UnionFind(int n) {
		count = n;
		parent = new int[n];
		size = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
			size[i] = 1;
		}
	}

	public int find(int p) {
		while (parent[p] != p) {
			p = parent[p];
		}
		return p;
	}

	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);
		if (pRoot == qRoot) {
			return;
		}
		if (size[pRoot] > size[qRoot]) {
			parent[qRoot] = pRoot;
			size[pRoot] += size[qRoot];
		} else {
			parent[pRoot] = qRoot;
			size[qRoot] += size[pRoot];
		}
		count--;
	}
}

```



## quick-unionåŸºäºrankçš„ä¼˜åŒ–

æ€è·¯ï¼šä½¿ç”¨`rank`æ•°ç»„å­˜æ”¾ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„æ·±åº¦

ä»£ç ï¼š

```java
public class UnionFind {
	private int[] parent;

	private int count;

	private int[] rank;	//ä»¥å½“å‰ç´¢å¼•ä¸ºæ ¹çš„æ ‘çš„æ·±åº¦

	public UnionFind(int n) {
		count = n;
		parent = new int[n];
		rank = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
			rank[i] = 1;
		}
	}

	public int find(int p) {
		while (parent[p] != p) {
			p = parent[p];
		}
		return p;
	}

	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);
		if (pRoot == qRoot) {
			return;
		}
		if (rank[pRoot] > rank[qRoot]) {
			parent[qRoot] = pRoot;
		} else if (rank[pRoot] < rank[qRoot]) {
			parent[pRoot] = qRoot;
		} else {
			parent[qRoot] = pRoot;
			rank[pRoot]++;
		}
		count--;
	}
}
```



## quick-unionåŸºäºè·¯å¾„å‹ç¼©çš„éé€’å½’å®ç°

> å¹¶æŸ¥é›†çš„ä¸€ä¸ªç‰¹æ€§æ˜¯ï¼Œåªè¦å…ƒç´ æ˜¯è¿åœ¨ä¸€èµ·çš„ï¼Œè°æŒ‡å‘è°å¹¶ä¸é‡è¦ã€‚

æ€è·¯ï¼šè·¯å¾„å‹ç¼©ï¼Œåœ¨`find`çš„æ—¶å€™è¿›è¡Œæ•´ç†ã€‚

ä»£ç ï¼š

```java
public class UnionFind {
	private int[] parent;

	private int count;

	public UnionFind(int n) {
		count = n;
		parent = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}

	public int find(int p) {
		while (parent[p] != p) {
            parent[p] = parent[parent[p]];//ä¸¤æ­¥ä¸€è·³
			p = parent[p];
		}
		return p;
	}

	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);
		if (pRoot == qRoot) {
			return;
		}
		parent[pRoot] = qRoot;//æˆ–è€…parent[pRoot]=qRoot;
		count--;
	}
}

```



## quick-unionåŸºäºè·¯å¾„å‹ç¼©çš„éé€’å½’å®ç°

ä»£ç ï¼š

```java
public class UnionFind {
	private int[] parent;

	private int count;

	public UnionFind(int n) {
		count = n;
		parent = new int[n];
		for (int i = 0; i < n; i++) {
			parent[i] = i;
		}
	}

	public int find(int p) {
		while (parent[p] != p) {
            parent[p] = find(parent[p]);
		}
		return parent[p];
	}

	public void union(int p, int q) {
		int pRoot = find(p);
		int qRoot = find(q);
		if (pRoot == qRoot) {
			return;
		}
		parent[pRoot] = qRoot;//æˆ–è€…parent[pRoot]=qRoot;
		count--;
	}
}

```

# ä¸¾ä¸ªæ —å­ğŸŒ°

## [LeetCode 547.æœ‹å‹åœˆ](https://leetcode-cn.com/problems/friend-circles/)

```java
class Solution {
    public int findCircleNum(int[][] M) {
		UnionFind uf = new UnionFind(M.length);
		for (int i = 0; i < M.length; i++) {
			for (int j = 0; j < M.length; j++) {
				if (M[i][j] == 1 && i != j) {
					uf.union(i, j);
				}
			}
		}
		return uf.count;
	}
    class UnionFind {
		private int[] parent;
		private int count;

		public UnionFind(int n) {
			count = n;
			parent = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
			}
		}

		public int find(int p) {
			while (parent[p] != p) {
    	        parent[p] = parent[parent[p]];
				p = parent[p];
			}
			return p;
		}

		public void union(int p, int q) {
			int pRoot = find(p);
			int qRoot = find(q);
			if (pRoot == qRoot) {
				return;
			}
			parent[pRoot] = qRoot;
			count--;
		}
	}
}
```

## [LeetCode 990.ç­‰å¼æ–¹ç¨‹çš„å¯æ»¡è¶³æ€§](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

```java
class Solution {
	public boolean equationsPossible(String[] equations) {
		UnionFind uf = new UnionFind(26);
		for (String s : equations) {
			if (s.charAt(1) == '=') {
				int p = s.charAt(0) - 'a';
				int q = s.charAt(3) - 'a';
				uf.union(p, q);
			}
		}
		for (String s : equations) {
			if (s.charAt(1) == '!') {
				int p = s.charAt(0) - 'a';
				int q = s.charAt(3) - 'a';
                //uf.isConnected(p, q)è¿”å›trueè¡¨ç¤ºp,qå¯ä»¥è¿æ¥ï¼Œä½†æ˜¯æ­¤æ—¶p!=qï¼ŒçŸ›ç›¾ï¼
				if (uf.isConnected(p, q)) {
					return false;
				}
			}
		}
		return true;
	}
    class UnionFind {
		private int[] parent;

		public UnionFind(int n) {
			parent = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
			}
		}

		public int find(int p) {
			while (parent[p] != p) {
    	        parent[p] = parent[parent[p]];
				p = parent[p];
			}
			return p;
		}

		public void union(int p, int q) {
			int pRoot = find(p);
			int qRoot = find(q);
			if (pRoot == qRoot) {
				return;
			}
			parent[pRoot] = qRoot;
		}
        
		public boolean isConnected(int p, int q) {
			return find(p) == find(q);
		}
	}
}
```

## [LeetCode 200.å²›å±¿çš„ä¸ªæ•°](https://leetcode-cn.com/problems/number-of-islands/)

> å¸¸è§çš„äºŒç»´åæ ‡è½¬åŒ–ä¸ºä¸€ç»´åæ ‡ï¼Œæ­¤é¢˜å…³é”®åœ¨äºå°†'0'åˆå¹¶åˆ°è™šæ‹ŸèŠ‚ç‚¹ä¸Š

```java
class Solution {
	public int numIslands(char[][] grid) {
		int m = grid.length;
		if (m < 1) {
			return 0;
		}
		int n = grid[0].length;
		int[][] directions = new int[][]{{1, 0}, {0, 1}};
    	int size = m * n;
		UnionFind uf = new UnionFind(size + 1);//size+1ç”¨äºå­˜æ”¾è™šæ‹ŸèŠ‚ç‚¹
		for (int i = 0; i < m; i++) {
			for (int j = 0; j < n; j++) {
				if (grid[i][j] == '1') {
					for (int[] direction : directions) {
						int newX = i + direction[0];
						int newY = j + direction[1];
						if (newX >= 0 && newX < m && newY >= 0 && newY < n && grid[newX][newY] == '1') {
							uf.union(getIndex(i, j, n), getIndex(newX, newY, n));
						}
					}
				} else {
					uf.union(getIndex(i, j, n), size);
				}
			}
		}
		return uf.count - 1;
	}

	private int getIndex(int x, int y, int cols) {
		return x * cols + y;
	}
    class UnionFind {
		private int[] parent;
		private int count;

		public UnionFind(int n) {
			count = n;
			parent = new int[n];
			for (int i = 0; i < n; i++) {
				parent[i] = i;
			}
		}

		public int find(int p) {
			while (parent[p] != p) {
    	        parent[p] = parent[parent[p]];
				p = parent[p];
			}
			return p;
		}

		public void union(int p, int q) {
			int pRoot = find(p);
			int qRoot = find(q);
			if (pRoot == qRoot) {
				return;
			}
			parent[pRoot] = qRoot;
			count--;
		}
	}
}
```

> å‚è€ƒï¼š[liwewei1419å¤§ä½¬çš„æ–‡ç«  é«˜çº§æ•°æ®ç»“æ„ï¼šå¹¶æŸ¥é›†](https://liweiwei1419.gitee.io/leetcode-algo/leetcode-by-tag/union-find/1319-number-of-operations-to-make-network-connected.html)